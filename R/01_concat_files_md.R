
#' @title Generating overview
#'
#' @description This function generates an overview of the available
#' files
#'
#' @param path_input Path to the directory where the Truhart files are saved
#'
gen_overview <- function(path_input = "D:/km/Truhart") {

  # Creating a list of all the available excel files. Important! The rows of the
  # overview function "excel_files" need to be ordered

  list.files(
    path = path_input,
    pattern = "xlsx",
    recursive = TRUE,
    full.names = TRUE
  ) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(
      Startpage =
        as.integer(
          stringi::stri_extract_last_regex(
            value,
            "[0-9]+(?=to|-)"
          )
        ),
      Endpage =
        as.integer(
          stringi::stri_extract_last_regex(
            value,
            "(?<=to|-)[0-9]+"
          )
        ),
      Continent =
        stringi::stri_extract_last_regex(
          value,
          "(?<=\\/km\\/Truhart\\/)[A-z]+"
        )
    ) %>%
    dplyr::arrange(Continent, Startpage)
}




#' @title Concatenating Excel-files
#'
#' @description This function concatenates the individual Excel-files to one
#'   R-file
#'
#' @keywords internal
concat_sheets <- function() {

  # Creating a list of all the available excel files. Important! The rows of the
  # overview function "excel_files" need to be ordered

  excel_files <- gen_overview()

  input_list <- list(
    input_path = excel_files[["value"]],
    input_continent = excel_files[["Continent"]],
    input_startpage = excel_files[["Startpage"]],
    input_endpage = excel_files[["Endpage"]]
  )

  # Function to create the individual excel sheets. This function is given as
  # input to the map function of "purrr" to concatenate the excel sheets

  gen_sheet <-
    function(input_path, input_continent, input_startpage, input_endpage) {

      # Suppress those annoying "New names:" messages

      suppressMessages(
        concat <-
          readxl::read_xlsx(
            path = input_path,
            col_names = FALSE,
            col_types = "text",
            .name_repair = "universal"
          )
      )

      # Not all of the excel files contain a "References" column,
      # since this column was only implemented later on.
      # In case the content of the fourth column got mistakenly inserted in the
      # fifth or sixth column

      if (ncol(concat) <= 3) {
        concat$References <- as.character(NA)
      } else if (ncol(concat) > 4) {
        concat <- concat %>%
          tidyr::unite(References, 4:ncol(concat), na.rm = TRUE)
      }

      # Renaming the columns/variables

      names(concat) <- c("ID", "Period", "Ruler", "References")

      sheet <-
        concat %>%
        dplyr::filter( # Removing empty rows
          !(is.na(ID) & is.na(Period) & is.na(Ruler) & is.na(References))
        ) %>%
        dplyr::mutate(
          Continent = input_continent,
          Startpage = input_startpage,
          Endpage = input_endpage,
          Excel_sheet = input_path,
          Excel_Row = dplyr::row_number()
        )

      return(sheet)
    }

  # Concatenating the individual sheets to one big R file

  excel_sheets <-
    purrr::pmap_dfr(input_list, gen_sheet) %>%
    dplyr::mutate(
      N = dplyr::row_number()
    )

  return(excel_sheets)
}

# Environment to store the index marking the header rows. That way, the
# header index can be carried over from one function to the next.

header_index <- new.env(parent = emptyenv())

#' @title Generate header
#'
#' @description The headers contain useful information i.e. the region and the
#'   country of the ruler. To extract these information, use is made of the fact
#'   that the left contains the region and the right header the country.
#'
#' @param sheet Sheet generated by function concat_sheets
#'
gen_header <- function(sheet) {
  sheet <- concat_sheets()

  # Sometimes part of the Ruler column was mistakenly put into the Reference
  # column or the other way around, therefore the Ruler and Reference columns
  # need to be merged in order to create the correct headers. However, a bit of
  # adjustment is required after the function "unite" from "dplyr" has been
  # called. By construction "unite" removes the word or placeholder NA and
  # leaves the entry empty. This can lead to problems, therefore blank cells are
  # replaced with NA. At the end the variable Ruler and ID are renamed to
  # Country and Region respectively because the Ruler column contains the header
  # specifying the Country and the ID column contains the header specifying the
  # Region.

  header <-
    sheet %>%
    tidyr::unite(
      Ruler_ref,
      c("Ruler", "References"),
      na.rm = TRUE, # Removing NA and replacing it with an empty space
      remove = TRUE, # Removing Ruler and References after the merge
      sep = " "
    ) %>%
    dplyr::mutate(
      Ruler = dplyr::na_if(Ruler_ref, ""), # Replacing "" with NA
      Ruler_ref = NULL, # dropping the variable Ruler_ref
    ) %>%
    dplyr::rename(Country = Ruler, Region = ID)

  # Create index for the relevant rows (those containing the header). To
  # identify the headers, only those rows are kept in which either the left and
  # middle columns and not the right column were empty or in which the right and
  # middle columns were empty and not the left column. Left header not empty ->
  # Part of continent; Right header not empty -> Name of country or region

  header_index$index <-
    header %>%
    dplyr::select(Region, Period, Country, N) %>%
    dplyr::filter(
      (!is.na(Region) & is.na(Period) & is.na(Country)) |
        (is.na(Region) & is.na(Period) & !is.na(Country))
    ) %>%
    magrittr::extract2("N") # Only selecting the variable N and creating a vector

  # Often a bit of adjustment is necessary in order to make sure that some rows
  # were not selected by mistake. Therefore regular expression are written to
  # make sure that the Region column starts with the page number and the country
  # column ends with the page number.

  header_cor <-
    header %>%
    dplyr::slice(header_index$index) %>% # Only select rows containing the header
    dplyr::filter(
      stringi::stri_detect_regex(Region, "^\\d{1,4} [A-z]+") |
        stringi::stri_detect_regex(Country, "[A-z]+\\)? \\d{1,4}$")
    ) %>%
    dplyr::select(
      Region, Country, Excel_Row, N,
      Excel_sheet, dplyr::everything(), -Period
    )

  # Export the header file to identify the wrong headers manually in the
  # excel sheets

  correction_required <- header_cor

  suppressMessages(
    usethis::use_data(correction_required,
      internal = FALSE,
      overwrite = TRUE,
      compress = "gzip",
      version = 3
    )
  )

  # For the last step, several variables variables are either created or
  # modified. Next the pages are extracted from the Region and country variables.
  # After the page number has been extracted, the variables Region and Country
  # are modified to delete the page number. Finally, Region and Country are
  # trimmed because the deletion of the page number leaves an empty space.

  header_final <-
    header_cor %>%
    dplyr::select(Region, Country, N) %>%
    dplyr::mutate(
      Page = stringr::str_extract(Region, "^\\d{1,4}"),
      Page = ifelse(
        is.na(Page),
        stringr::str_extract(Country, "\\d{1,4}$"),
        Page
      ) %>%
        as.integer(),
      Region = stringr::str_remove(Region, "^\\d{1,4}") %>%
        stringr::str_squish(),
      Country = stringr::str_remove(Country, "\\d{1,4}$") %>%
        stringr::str_squish()
    )

  return(header_final)
}


#' @title Final Sheet
#'
#' @description Finalizing the sheet
#'
#' @export
#'
finalize_sheet <- function() {
  sheet <- concat_sheets()

  header <- gen_header(sheet)

  file <-
    dplyr::left_join(sheet, header, by = "N") %>%
    dplyr::relocate(
      ID, Period, Ruler, References, Region, Country, Page
    ) %>%
    dplyr::mutate(
      Region = zoo::na.locf(Region, na.rm = FALSE),
      Country = zoo::na.locf(Country, na.rm = FALSE),
      Country = zoo::na.locf(Country, na.rm = FALSE, fromLast = TRUE),
      Page = zoo::na.locf(Page, na.rm = FALSE),
      Ruler = stringr::str_squish(Ruler), # Removes repeated white spaces
      ID = gsub(" ", "", ID), # ID cannot contain empty spaces!
      Period = stringr::str_squish(Period) # sames as before
    ) %>%
    dplyr::slice(-header_index$index) %>% # Remove rows containing the header
    dplyr::arrange(Continent, Page, Excel_Row) # Very important!


  return(file)
}
